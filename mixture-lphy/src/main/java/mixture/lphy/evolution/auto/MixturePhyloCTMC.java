package mixture.lphy.evolution.auto;

import lphy.base.distribution.Categorical;
import lphy.base.evolution.alignment.Alignment;
import lphy.base.evolution.likelihood.AbstractPhyloCTMC;
import lphy.base.evolution.tree.TimeTree;
import lphy.core.model.GenerativeDistribution;
import lphy.core.model.Generator;

import lphy.core.model.RandomVariable;
import lphy.core.model.Value;
import lphy.core.model.ValueUtils;
import lphy.core.model.annotation.GeneratorCategory;
import lphy.core.model.annotation.GeneratorInfo;
import lphy.core.model.annotation.ParameterInfo;
import lphy.core.simulator.RandomUtils;
import org.apache.commons.math3.random.RandomGenerator;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Objects;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * MixturePhyloCTMC (simulation helper):
 *
 * - If index is provided: deterministically sample exactly ONE component.
 * - Else: sample component by weights, again sampling exactly ONE component.
 *
 * IMPORTANT:
 * This class is for SIMULATION. When mapping to BEAST, index is typically ignored and
 * you build an actual mixture likelihood there.
 *
 * About "D equals D_relaxed/D_strict":
 * We return the chosen Alignment as D. We optionally try to write it back into the chosen
 * component Value so that inspecting that component in UI shows the same object.
 * This write-back is BEST-EFFORT ONLY because LPhy Value/RandomVariable may be immutable.
 */
public final class MixturePhyloCTMC implements GenerativeDistribution<Alignment>, PhyloLikelihood {

    public static final String COMP1   = "comp1";
    public static final String COMP2   = "comp2";
    public static final String COMP3   = "comp3";
    public static final String WEIGHTS = "weights";
    public static final String INDEX   = "index";          // simulation only
    public static final String SYNC    = "syncComponents"; // optional, debug only

    private Value<Alignment> comp1;
    private Value<Alignment> comp2;
    private Value<Alignment> comp3; // optional
    private Value<Double[]>  weights;
    private Value<Integer>   index; // optional
    private Value<Boolean>   syncComponents; // optional

    private AbstractPhyloCTMC[] gens;
    private final RandomGenerator rng = RandomUtils.getRandom();

    // Cache: ensures repeated calls to sample() in the same evaluation return the same D
    private transient Alignment cachedD = null;
    private transient Integer cachedK = null;
    private transient boolean hasCached = false;

    public MixturePhyloCTMC(
            @ParameterInfo(name = COMP1, description = "First component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp1,
            @ParameterInfo(name = COMP2, description = "Second component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp2,
            @ParameterInfo(name = WEIGHTS, description = "Mixture weights (length 2 simplex).")
            Value<Double[]> weights,
            @ParameterInfo(name = INDEX, description = "Optional component index (0 or 1) used for SIMULATION ONLY; ignored when mapping to BEAST.", optional = true)
            Value<Integer> index,
            @ParameterInfo(name = SYNC, description = "Debug only: try to write chosen Alignment back to the chosen component Value (best-effort).", optional = true)
            Value<Boolean> syncComponents
    ) {
        this.comp1 = Objects.requireNonNull(comp1, "comp1 is required");
        this.comp2 = Objects.requireNonNull(comp2, "comp2 is required");
        this.comp3 = null;
        this.weights = Objects.requireNonNull(weights, "weights is required");
        this.index = index;
        this.syncComponents = syncComponents;
        rebuildGensAndValidate();
    }

    public MixturePhyloCTMC(
            @ParameterInfo(name = COMP1, description = "First component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp1,
            @ParameterInfo(name = COMP2, description = "Second component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp2,
            @ParameterInfo(name = COMP3, description = "Third component alignment RV generated by a phylogenetic CTMC.")
            Value<Alignment> comp3,
            @ParameterInfo(name = WEIGHTS, description = "Mixture weights (length 3 simplex).")
            Value<Double[]> weights,
            @ParameterInfo(name = INDEX, description = "Optional component index (0, 1 or 2) used for SIMULATION ONLY; ignored when mapping to BEAST.", optional = true)
            Value<Integer> index,
            @ParameterInfo(name = SYNC, description = "Debug only: try to write chosen Alignment back to the chosen component Value (best-effort).", optional = true)
            Value<Boolean> syncComponents
    ) {
        this.comp1 = Objects.requireNonNull(comp1, "comp1 is required");
        this.comp2 = Objects.requireNonNull(comp2, "comp2 is required");
        this.comp3 = Objects.requireNonNull(comp3, "comp3 is required");
        this.weights = Objects.requireNonNull(weights, "weights is required");
        this.index = index;
        this.syncComponents = syncComponents;
        rebuildGensAndValidate();
    }

    private void rebuildGensAndValidate() {
        final int nComp = (comp3 == null) ? 2 : 3;

        Generator g1 = Objects.requireNonNull(comp1.getGenerator(),
                "comp1 must be produced by a phylo generator (e.g., PhyloCTMC)");
        Generator g2 = Objects.requireNonNull(comp2.getGenerator(),
                "comp2 must be produced by a phylo generator (e.g., PhyloCTMC)");

        if (!(g1 instanceof AbstractPhyloCTMC) || !(g2 instanceof AbstractPhyloCTMC)) {
            throw new IllegalArgumentException("comp1/comp2 must be generated by a PhyloCTMC-like generator.");
        }

        if (nComp == 2) {
            gens = new AbstractPhyloCTMC[]{ (AbstractPhyloCTMC) g1, (AbstractPhyloCTMC) g2 };
        } else {
            Generator g3 = Objects.requireNonNull(comp3.getGenerator(),
                    "comp3 must be produced by a phylo generator (e.g., PhyloCTMC)");
            if (!(g3 instanceof AbstractPhyloCTMC)) {
                throw new IllegalArgumentException("comp3 must be generated by a PhyloCTMC-like generator.");
            }
            gens = new AbstractPhyloCTMC[]{ (AbstractPhyloCTMC) g1, (AbstractPhyloCTMC) g2, (AbstractPhyloCTMC) g3 };
        }

        // Trees must be shared
        if (gens[0].getTree() != gens[1].getTree()
                || (nComp == 3 && gens[2].getTree() != gens[0].getTree())) {
            throw new IllegalArgumentException("All components must reference the *same* TimeTree instance.");
        }

        // Do NOT call index.value() here (may be null before sampling).
        // Do NOT require weights.value() to be non-null here (some pipelines materialize later).
        // We'll validate weights at sampling time.
    }

    @GeneratorInfo(
            name = "MixturePhyloCTMC",
            verbClause = "is assumed to have evolved under a mixture of",
            narrativeName = "phylogenetic CTMC mixture",
            examples = {"mixtureLikelihood.lphy"},
            category = GeneratorCategory.PHYLO_LIKELIHOOD,
            description = "Mixture of two or three component phylogenetic likelihoods that apply to the same alignment."
    )
    @Override
    public RandomVariable<Alignment> sample() {

        // Return cached value if already sampled in this evaluation
        if (hasCached && cachedD != null) {
            return new RandomVariable<>("D", cachedD, this);
        }

        final int nComp = (comp3 == null) ? 2 : 3;

        final int k = chooseComponentIndex(nComp);

        Alignment chosen = realiseChosenComponent(k);

        // Cache
        cachedD = chosen;
        cachedK = k;
        hasCached = true;

        return new RandomVariable<>("D", chosen, this);
    }

    private int chooseComponentIndex(int nComp) {
        // Deterministic selection if index provided
        if (index != null) {
            Integer kObj = index.value();
            if (kObj == null) {
                throw new IllegalStateException("MixturePhyloCTMC: index was provided but has no realised value yet.");
            }
            int k = kObj;
            if (k < 0 || k >= nComp) {
                throw new IllegalArgumentException("index must be in [0.." + (nComp - 1) + "] (got " + k + ").");
            }
            return k;
        }

        // Otherwise sample by weights
        Double[] w = weights.value();
        if (w == null || w.length != nComp) {
            throw new IllegalStateException("MixturePhyloCTMC: weights must be realised and have length " + nComp + ".");
        }

        validateWeights(w);

        return Categorical.sample(w, rng);
    }

    private static void validateWeights(Double[] w) {
        double sum = 0.0;
        for (int i = 0; i < w.length; i++) {
            Double wiObj = w[i];
            if (wiObj == null || !Double.isFinite(wiObj)) {
                throw new IllegalArgumentException("MixturePhyloCTMC: weights contain NaN/Inf/null at index " + i);
            }
            double wi = wiObj;
            if (wi < 0.0) {
                throw new IllegalArgumentException("MixturePhyloCTMC: negative weight at index " + i + ": " + wi);
            }
            sum += wi;
        }
        if (!(Math.abs(sum - 1.0) <= 1e-8)) {
            throw new IllegalArgumentException("MixturePhyloCTMC: weights must sum to 1.0 (got " + sum + ").");
        }
    }

    private Alignment realiseChosenComponent(int k) {
        // First try to get component Value (may already be realised/cached by engine)
        Value<Alignment> compVal = getCompValueByIndex(k);
        Alignment existing = (compVal == null) ? null : compVal.value();
        if (existing != null) {
            return existing;
        }

        // Otherwise: sample directly from the chosen generator (sample EXACTLY ONCE)
        Alignment sampled = gens[k].sample().value();

        // Optional debug: try to write it back so compk.value() shows the same object
        if (shouldSyncComponents() && compVal != null && sampled != null) {
            boolean ok = tryWriteBackValue(compVal, sampled);
            if (!ok) {
                // Best-effort only; do not fail simulation.
                System.err.println("[MixturePhyloCTMC] Warning: could not write back sampled Alignment to component " + k +
                        ". D is correct; component Value may not be synchronized.");
            }
        }

        return sampled;
    }

    private boolean shouldSyncComponents() {
        return syncComponents != null && Boolean.TRUE.equals(syncComponents.value());
    }

    private Value<Alignment> getCompValueByIndex(int k) {
        if (k == 0) return comp1;
        if (k == 1) return comp2;
        if (k == 2) return comp3;
        throw new IllegalArgumentException("component index out of range: " + k);
    }

    /**
     * Best-effort write-back into the chosen component Value.
     * This may fail if Value is immutable or module-sealed.
     *
     * Strategy:
     *  1) Look for declared method named setValue/set/assign with 1 argument and invoke it.
     *  2) Look for a declared field named value/_value/val and set it.
     */
    private static boolean tryWriteBackValue(Value<Alignment> target, Alignment newVal) {

        // (1) Declared methods, including non-public
        String[] methodNames = {"setValue", "set", "assign"};
        for (String mName : methodNames) {
            for (Class<?> c = target.getClass(); c != null; c = c.getSuperclass()) {
                for (Method m : c.getDeclaredMethods()) {
                    if (!m.getName().equals(mName)) continue;
                    if (m.getParameterCount() != 1) continue;
                    try {
                        m.setAccessible(true);
                        m.invoke(target, newVal);
                        return true;
                    } catch (Throwable ignored) {
                        // try next
                    }
                }
            }
        }

        // (2) Declared field names commonly used
        String[] fieldNames = {"value", "_value", "val"};
        for (String fName : fieldNames) {
            try {
                Field f = null;
                for (Class<?> c = target.getClass(); c != null && f == null; c = c.getSuperclass()) {
                    try {
                        f = c.getDeclaredField(fName);
                    } catch (NoSuchFieldException ignored) {}
                }
                if (f != null) {
                    f.setAccessible(true);
                    f.set(target, newVal);
                    return true;
                }
            } catch (Throwable ignored) {
                // try next
            }
        }

        return false;
    }

    @Override
    public SortedMap<String, Value> getParams() {
        SortedMap<String, Value> map = new TreeMap<>();
        map.put(COMP1, comp1);
        map.put(COMP2, comp2);
        if (comp3 != null) map.put(COMP3, comp3);
        map.put(WEIGHTS, weights);
        if (index != null) map.put(INDEX, index);
        if (syncComponents != null) map.put(SYNC, syncComponents);
        return map;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void setParam(String name, Value value) {
        // Changing params should invalidate cache
        clearCache();

        switch (name) {
            case COMP1   -> { this.comp1 = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case COMP2   -> { this.comp2 = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case COMP3   -> { this.comp3 = (Value<Alignment>) value; rebuildGensAndValidate(); }
            case WEIGHTS -> { this.weights = (Value<Double[]>) value; }
            case INDEX   -> { this.index = (Value<Integer>) value; }
            case SYNC    -> { this.syncComponents = (Value<Boolean>) value; }
            default      -> throw new RuntimeException("Unrecognised parameter name: " + name);
        }
    }

    private void clearCache() {
        cachedD = null;
        cachedK = null;
        hasCached = false;
    }

    @Override public Value<TimeTree> getTree() { return gens[0].getTree(); }
    @Override public Value<Number> getClockRate() { return gens[0].getClockRate(); }
    @Override public Value<Double[]> getBranchRates() { return gens[0].getBranchRates(); }
}
